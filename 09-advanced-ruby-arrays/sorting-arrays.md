# Sorting Arrays
{"canmore.create\_textdoc": {"name": "sorting\_arrays", "type": "document", "content": "# Sorting Arrays\n\nSorting Arrays คือการเรียงข้อมูลใน array โดยสามารถเรียงข้อมูลให้เป็นไปตามที่เรากำหนดได้ว่าอยากให้เรียงข้อมูล array ให้เรียงในรูปแบบที่ต้องการ  \n\nโดย Ruby จะมีการ sorting ทั้งหมด 4 รูปแบบแบบชัดเจนได้ดังนี้ :\n1. sort (ที่จะไม่ทำการเปลี่ยนแปลงค่าเดิมใน array)\n2. sort! (ที่จะทำการเปลี่ยนแปลงค่าเดิมใน array)\n3. sort\_by (ที่จะไม่ทำการเปลี่ยนแปลงค่าเดิมใน array โดยจะใช้  block ในการเปลี่ยนแปลงค่า)\n4. sort\_by! (ที่จะทำการเปลี่ยนแปลงค่าเดิมใน array โดยจะใช้  block ในการเปลี่ยนแปลงค่า)\n\nก่อนจะเริ่มการเปรียบเทียบเนื่องจากภาษา c ไม่มีฟังก์ชันที่เกื้อหนุนกับการใช้ sorting array มากเท่าที่ควร เนื่องจากภาษา c เป็นภาษาระดับต่ำเป็นสาเหตุที่ทำให้ต้องเน้นในเรื่องของประสิทธิภาพและการควบคุมหน่วยความจำที่ต้องจัดการเอง โดยทำให้มีแค่ฟังก์ชันแค่ qsort ทำให้ต้องมีการสร้าง ฟังก์ชั่นเปรียบเทียบเพื่อให้สามารถนำภาษา c มาเปรียบเทียบกับภาษา ruby ได้โดยตัวของ code สำหรับการใช้งานจะมีดังนี้\n\n`c\n#include <stdio.h>    // สำหรับ I/O เช่น printf\n#include <stdlib.h>   // สำหรับ qsort, malloc, free\n#include <string.h>   // สำหรับ strcmp, strlen, memcpy\n\nint compareStrings(const void *a, const void *b) {\n    const char **str_a = (const char **)a;\n    const char **str_b = (const char **)b;\n    return strcmp(*str_a, *str_b);\n} // ฟังก์ชันเปรียบเทียบ String ตามลำดับตัวอักษร ซึ่งหลักการทำงานจะคล้ายกับตัว sort ของ ruby \n\nint compareByLength(const void *a, const void *b) {\n    const char **str_a = (const char **)a;\n    const char **str_b = (const char **)b;\n    int len_a = strlen(*str_a);\n    int len_b = strlen(*str_b);\n    return (len_a > len_b) - (len_a < len_b); // เทคนิคคืนค่า -1, 0, หรือ 1\n} // ฟังก์ชันเปรียบเทียบ String ตามความยาวตัวอักษร ซึ่งหลักการทำงานจะคล้ายกับตัว sort_by ของ ruby\n\nvoid printArray(const char *arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        printf(\"%s \", arr[i]);\n    }\n    printf(\"\\n\");\n} // ตัวสำหรับการพิมพ์ Array ให้เข้าใจง่ายๆ\n`\n\n---\n\n## 1. sort (ที่จะไม่ทำการเปลี่ยนแปลงค่าเดิมใน array)\n\nโดยการทำแบบนี้จะเป็นการเรียงค่าใน array โดยจะต้องมี array อีกตัวหนึ่งในการเก็บค่า array ที่ได้ทำการเรียงข้อมูลผ่านการ sort ไว้แล้ว  \nโดยวิธีการใช้งานสามารถใช้งานได้ดังนี้ :\n\n**ruby**\n`ruby\nnumbers = [3, 1, 5, 2, 4]\nsorted_numbers = numbers.sort\nputs sorted_numbers  # ผลลัพธ์ที่ได้ => [1, 2, 3, 4, 5]\n`\n\n**c**\n`c\nconst char *original1[] = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nint n = sizeof(original1) / sizeof(original[0]);\nconst char **sorted_copy = malloc(n * sizeof(const char *)); // จะเป็นการสร้าง array เพื่อมาเตรียมพร้อมสำหรับการใส่ค่าที่เรียงไว้\nmemcpy(sorted_copy, original1, n * sizeof(const char *)); // ทำการคัดลอกข้อมูลจาก original1 มาใส่ยังตัว  sorted_copy\nqsort(sorted_copy, n, sizeof(const char *), compareStrings); // เรียงลำดับภายใน  Array ใหม่ แล้วทำมาใส่ตัวของ sorted_copy โดยใช้คำสั่ง qsort\nprintArray(sorted_copy,n); // ผลลัพธ์ที่ได้ => apple banana fig kiwi\nfree(sorted_copy); // เพื่อคืนหน่วยความจำจากการสร้างมา\n`\n\n**java**\n`java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nList<String> words = Arrays.asList(\"kiwi\", \"apple\", \"fig\", \"banana\");\nList<String> sortedWords = words.stream().sorted().collect(Collectors.toList()); // ส่วนที่เหมือนกับ sort โดย สร้าง List ใหม่ชื่อ sortedWords จากการเรียงลำดับ\nSystem.out.println(sortedWords); // ผลลัพธ์ที่ได้ => [apple, banana, fig, kiwi]\n`\n\n**python**\n`python\nwords = [\"kiwi\", \"apple\", \"fig\", \"banana\"]\nnew_words = sorted(words) # สร้างตัวเก็บ array มาใหม่โดยที่ไม่มีการเปลี่ยนแปลงค่าใน array ของตัว words โดยหลังจากนั้นจะทำการเรียงข้อมูลเพื่อมาเก็บใน array ของ new_words\nprint(f\"New sorted list: {new_words}\") # ผลลัพธ์ที่ได้ => ['apple', 'banana', 'fig', 'kiwi']\n`\n\n---\n\n## 2. sort! (ที่จะทำการเปลี่ยนแปลงค่าเดิมใน array)\n\nโดยการทำแบบนี้จะเป็นการเรียงค่าใน array โดยสามารถเรียงค่าผ่านทาง array ได้โดยตรง ผ่านการใช้ sort! ได้เลย ซึ่งจะแตกต่างจาก sort ตรงที่จะต้องมีตัว array อีกตัวที่คอยมารับค่า  \nโดยวิธีการใช้งานสามารถใช้งานได้ดังนี้ :\n\n**ruby**\n`ruby\nnumbers = [3, 1, 5, 2, 4]\nnumbers.sort!\nputs numbers  # ผลลัพธ์ที่ได้ => [1, 2, 3, 4, 5]\n`\n\n**c**\n`c\nconst char *words1[] = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nint n = sizeof(words1) / sizeof(words1[0]);\nqsort(words1, n, sizeof(const char *), compareStrings); // เรียงลำดับภายใน  Array ใหม่ แล้วทำมาใส่ตัวของ word1 เข้าไปตรงๆ โดยใช้คำสั่ง qsort\nprintArray(\"Sorted (in-place)\", words1, n); // ผลลัพธ์ที่ได้ => apple banana fig kiwi\n`\n\n**java**\n`java\nimport java.util.Arrays;\n\nString[] words = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nArrays.sort(words); // ส่วนที่เหมือนกับ sort! โดยมีการเรียงลำดับภายใน array ของ  words โดยตรง\nSystem.out.println(Arrays.toString(words)); // ผลลัพธ์ที่ได้ => [apple, banana, fig, kiwi]\n`\n\n**python**\n`python\nwords = [\"kiwi\", \"apple\", \"fig\", \"banana\"]\nwords.sort() # ทำการเรียงค่าใน array ของ words โดยตรง\nprint(f\"After sort():  {words_to_modify}\") # ผลลัพธ์ที่ได้ => ['apple', 'banana', 'fig', 'kiwi']\n`\n\n---\n\n## 3. sort\_by (ที่จะไม่ทำการเปลี่ยนแปลงค่าเดิมใน array โดยจะใช้ block ในการเปลี่ยนแปลงค่า)\n\nโดยการทำแบบนี้จะเป็นการเรียงค่าใน array โดยใช้  block หรือเรียกอีกอย่างว่าเงื่อนไข ในการเรียงค่า โดยจะต้องมี array อีกตัวที่คอยรับค่าที่ผ่านการเรียงข้อมูลด้วย sort\_by ไว้แล้ว  \nโดยวิธีการใช้งานสามารถใช้งานได้ดังนี้ :\n\n**ruby**\n`ruby\nwords = [\"ruby\", \"is\", \"awesome\"]\nsorted_words = words.sort_by { |word| word.length }\nputs sorted_words # ผลลัพธ์ที่ได้ => [\"is\", \"ruby\", \"awesome\"]\n`\n\n**c**\n`c\nconst char *original4[] = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nint n = sizeof(original4) / sizeof(original4[0]);\nconst char **sorted_by_copy = malloc(n * sizeof(const char *));\nmemcpy(sorted_by_copy, original4, n * sizeof(const char *));\nqsort(sorted_by_copy, n, sizeof(const char *), compareByLength); // เรียงลำดับ Array ใหม่โดยใช้เงื่อนไข compareByLength ที่เรียงผ่านการใช้ความยาวเป็นเกณฑ์ โดยจะเก็บเข้าไปใน sorted_by_copy\nprintArray(sorted_by_copy, n); // ผลลัพธ์ที่ได้ => fig kiwi apple banana \nfree(sorted_by_copy); // เพื่อคืนหน่วยความจำจากการสร้างมา\n`\n\n**java**\n`java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Comparator;\nimport java.util.stream.Collectors;\n\nList<String> words = Arrays.asList(\"kiwi\", \"apple\", \"fig\", \"banana\");\nList<String>sortedWords=words.stream().sorted(Comparator.comparingInt(String::length)).collect(Collectors.toList()); // ส่วนที่เหมือนกับ sort_by โดยมีการเรียงลำดับและจะมีการจดเก็บไว้ในตัวของ sortedWords โดยตรงร่วมกับการใช้เงื่อนไขความยาวของ String\n`\n\n**python**\n`python\npeople = [\n    {'name': 'somsak', 'age': 35},\n    {'name': 'malee', 'age': 28},\n    {'name': 'piti', 'age': 42}\n]\nnew_people_sorted_by_age = sorted(people, key=lambda person: person['age'])  # สร้างตัวเก็บ array มาใหม่โดยที่ไม่มีการเปลี่ยนแปลงค่าใน array ของตัว people โดยหลังจากนั้นจะทำการเรียงข้อมูลเพื่อมาเก็บใน array ของ new_people_sorted_by_age โดยทำการเรียงโดยใช้ age เป็นเกณฑ์\nprint(\"{new_people_sorted_by_age}\") # ผลลัพธ์ที่ได้ => [{'name': 'malee', 'age': 28}, {'name': 'somsak', 'age': 35}, {'name': 'piti', 'age': 42}]\n`\n\n---\n\n## 4. sort\_by! (ที่จะทำการเปลี่ยนแปลงค่าเดิมใน array โดยจะใช้ block ในการเปลี่ยนแปลงค่า)\n\nโดยการทำแบบนี้จะเป็นการเรียงค่าใน array โดยใช้  block หรือเรียกอีกอย่างว่าเงื่อนไข โดยสามารถเรียงค่าผ่านทาง array ได้โดยตรงผ่านการใช้ sort\_by!  ได้เลย ซึ่งจะแตกต่างจาก sort\_by ตรงที่จะต้องมีตัว array อีกตัวที่คอยมารับค่า  \nโดยวิธีการใช้งานสามารถใช้งานได้ดังนี้ :\n\n**ruby**\n`ruby\nwords = [\"ruby\", \"is\", \"awesome\"]\nwords.sort_by! { |word| word.length }\nputs words # ผลลัพธ์ที่ได้ => [\"is\", \"ruby\", \"awesome\"]\n`\n\n**c**\n`c\nconst char *words1[] = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nint n = sizeof(words1) / sizeof(words1[0]);\nqsort(words1, n, sizeof(const char *), compareByLength); // เรียงลำดับ Array ใหม่โดยใช้เงื่อนไข compareByLength ที่เรียงผ่านการใช้ความยาวเป็นเกณฑ์ และเก็บเข้าไปยัง word1 โดยตรง\n\nprintArray(\"Sorted by length\", words2, n);\nprintf(\"\\n\");\n`\n\n**java**\n`java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nString[] words = {\"kiwi\", \"apple\", \"fig\", \"banana\"};\nArrays.sort(words, Comparator.comparingInt(String::length)); // ส่วนที่เหมือนกับ sort_by! โดยมีการเรียงลำดับภายใน array ของ  words โดยตรงร่วมกับการใช้เงื่อนไขความยาวของ String\nSystem.out.println(Arrays.toString(words)); // ผลลัพธ์ที่ได้ => [fig, kiwi, apple, banana]\n`\n\n**python**\n`python\npeople = [\n    {'name': 'somsak', 'age': 35},\n    {'name': 'malee', 'age': 28},\n    {'name': 'piti', 'age': 42}\n]\npeople.sort(key=lambda person: person['age']) # ทำการเรียงค่าใน array ของ people โดยตรงร่วมกับการใช้เงื่อนไขการเรียง array โดยใช้ age เรียงค่าข้อมูล\nprint(\"{people}\")  # ผลลัพธ์ที่ได้ => [{'name': 'malee', 'age': 28}, {'name': 'somsak', 'age': 35}, {'name': 'piti', 'age': 42}]\n`\n\n---\n\n## โดยจะสรุปความแตกต่างแบบเป็นตารางเพื่อให้เข้าใจได้ง่ายแบบสรุปได้ดังนี้\n\n| ภาษา   | sort (ไม่เปลี่ยนค่าเดิม) | sort! (เปลี่ยนค่าเดิม) | sort\_by (ไม่เปลี่ยนค่าเดิม + เงื่อนไข) | sort\_by! (เปลี่ยนค่าเดิม + เงื่อนไข) |\n|--------|-----------------------------|---------------------------|-----------------------------------------|------------------------------------------|\n| Ruby   | `array.sort` -> คืนค่าใหม่ | `array.sort!` -> เรียงใน array เดิม | `array.sort_by { |x| cond }` -> คืนค่าใหม่ | `array.sort_by! { |x| cond }` -> เรียงใน array เดิม |\n| C      | ใช้ `qsort` กับ copy ของ array | ใช้ `qsort` กับ array เดิม | ใช้ `qsort` กับ comparator ที่กำหนด (copy array) | ใช้ `qsort` กับ comparator ที่กำหนด (array เดิม) |\n| Java   | `stream().sorted()` -> คืนค่าใหม่ | `Arrays.sort(arr)` -> เรียงใน array เดิม | `stream().sorted(Comparator)` -> คืนค่าใหม่ | `Arrays.sort(arr, Comparator)` -> เรียงใน array เดิม |\n| Python | `sorted(arr)` -> คืนค่าใหม่ | `arr.sort()` -> เรียงใน list เดิม | `sorted(arr, key=cond)` -> คืนค่าใหม่ | `arr.sort(key=cond)` -> เรียงใน list เดิม |\n\n---\n\n# แหล่งอ้างอิง\n\n### ruby\n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ array: [Ruby Array](https://docs.ruby-lang.org/en/master/Array.html) ไม่พบวันที่เขียนหน้าเว็บไซต์ สืบค้นเมื่อวันที่ 31 สิงหาคม พ.ศ. 2568  \n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ sorting array: [Ruby Array sort](https://docs.ruby-lang.org/en/master/Array.html#method-i-sort) ไม่พบวันที่เขียนหน้าเว็บไซต์ สืบค้นเมื่อวันที่ 31 สิงหาคม พ.ศ. 2568  \n- หนังสือสำหรับการค้นหาในเรื่องของ sorting array  \n  1. Programming Ruby 1.9 & 2.0 – The Pragmatic Programmers' Guide หน้า 437  = [PDF](https://github.com/maniramakumar/the-best-ruby-books/blob/master/books/Programming%20Ruby%201.9%20%26%202.0%20-%20The%20Pragmatic%20Programmers'%20Guide%20-%20Fourth%20Edition.pdf) เขียน ณ วันที่ 15 มิถุนายน พ.ศ. 2556 สืบค้นเมื่อวันที่ 31 สิงหาคม พ.ศ. 2568  \n  2. The Ruby Programming Language หน้า 338 = [PDF](https://github.com/maniramakumar/the-best-ruby-books/blob/master/books/The%20Ruby%20Programming%20Language.pdf) เขียน ณ วันที่ 24 กุมภาพันธ์ 2536 สืบค้นเมื่อวันที่ 31 สิงหาคม พ.ศ. 2568  \n  3. Ruby Recipes – A Problem-Solution Approach หน้า 84 = [PDF](https://github.com/maniramakumar/the-best-ruby-books/blob/master/books/Ruby%20Recipes%20-%20A%20Problem-Solution%20Approach.pdf) เขียน ณ วันที่ 8 ธันวาคม พ.ศ. 2559 สืบค้นเมื่อวันที่ 31 สิงหาคม พ.ศ. 2568  \n\n### java\n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ array: [Java Arrays](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html) ไม่พบวันที่เขียนหน้าเว็บไซต์ สืบค้นเมื่อวันที่ 2 กันยายน พ.ศ. 2568  \n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ sort: [Java Arrays sort](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html#sort%28java.lang.Object%5B%5D%29)  \n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ sorted: [Java Stream sorted](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#sorted%28%29)  \n- เว็บไซต์ทางการสำหรับการค้นหาในเรื่องของ Stream: [Java Stream Comparator](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#sorted%28java.util.Comparator%29)  \n\n### c\n- เว็บไซต์ของ

